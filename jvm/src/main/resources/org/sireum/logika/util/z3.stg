main(d, a, e) ::= <<
; Preamble
(define-sort B () Bool)                      ; Logika's B type
(define-sort Z () Int)                       ; Logika's Z type
(define-sort ZS () (Array Z Z))              ; Logika's ZS type
(declare-fun _size (ZS) Z)                   ; ZS _size proof function
(assert (forall ((a ZS)) (>= (_size a) 0)))  ; ZS _size axiom: _size of any ZS must be non-negative
(declare-const _empty ZS)                    ; ZS _empty constant
(assert (= _empty ((as const ZS) 0)))        ; ZS _empty axiom: no element in _empty
(assert (= (_size _empty) 0))                ; ZS _size and _empty axiom: _size of _empty is 0

; Type Declarations
$d$
; Auxiliaries
$if(a)$
$a$
$else$

$endif$
; Axioms and Query
$e$(check-sat)
>>

assertion(e) ::= <<
(assert $e$)
>>

bconst(name) ::= <<
(declare-const l_$name$ B)
>>

zconst(name) ::= <<
(declare-const l_$name$ Z)
>>

zsconst(name) ::= <<
(declare-const l_$name$ ZS)
>>

fun(name, param, result) ::= <<
(declare-fun l_$name$ ($param; separator=" "$) $result$)
>>

truelit() ::= <<
true
>>

falselit() ::= <<
false
>>

id(value) ::= <<
l_$value$
>>

size(id) ::= <<
(_size $id$)
>>

index(a, i) ::= <<
(select $a$ $i$)
>>

apply(id, exp) ::= <<
($id$ $exp; separator=" "$)
>>

int(value) ::= <<
$value$
>>

binary(op, left, right) ::= <<
($op$ $left$ $right$)
>>

unary(op, exp) ::= <<
($op$ $exp$)
>>

quant(op, param, exp) ::= <<
($op$ ($param; separator=" "$) $exp$)
>>

param(id, tipe) ::= <<
($id$ $tipe$)
>>

a(c) ::= <<
_a!$c$
>>

zs(c, exp, size) ::= <<
(declare-const _a!$c$ ZS)
(assert (= _a!$c$ $exp$))
(assert (= (_size _a!$c$) $size$))
>>

zsexp(a, i, v) ::= <<
(store $if(a)$$a$$else$_empty$endif$ $i$ $v$)
>>

prepend(c, a, v) ::= <<
(declare-const _a!$c$ ZS)
(assert (= (_size _a!$c$) (+ (_size $a$) 1)))
(assert (= (select _a!$c$ 0) $v$))
(assert
  (forall ((_i Z))
    (=>
      (and (< 0 _i) (< _i (_size _a!$c$)))
      (= (select _a!$c$ _i) (select $a$ (- _i 1)))
    )
  )
)
>>

append(c, a, v) ::= <<
(declare-const _a!$c$ ZS)
(assert (= (_size _a!$c$) (+ (_size $a$) 1)))
(assert (= (select _a!$c$ (_size $a$)) $v$))
(assert
  (forall ((_i Z))
    (=>
      (and (<= 0 _i) (< _i (_size $a$)))
      (= (select _a!$c$ _i) (select $a$ _i))
    )
  )
)
>>


zsequal(a1, a2) ::= <<
(and
  (= (_size $a1$) (_size $a2$))
  (forall ((_i Z))
    (=>
      (and (<= 0 _i) (< _i (_size $a1$)))
      (= (select $a1$ _i) (select $a2$ _i))
    )
  )
)
>>